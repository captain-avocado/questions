# Хоистинг. Var, let, const.

## Хоистинг

**Хоистинг (всплытие)** – всплытие переменных и функций в js, то есть переменная/функция может быть использована до того, как объявлена. 
Интерпретатор поднимает объявление (но не инициализацию) переменных внутри ОВ, а также функции целиком, если они объявлены с помощью function declaration.

Пример:

```js
function foo() {
  //какой-то код
  var x = 1;
}
```

На самом деле интерпретатор читает так:

```js
function foo() {
  var x;
  //какой-то код
  x = 1;
}
```

Таким образом переменные можно использовать до их объявления.

```js
function foo() {
  x = 5;
  console.log(x);
  var x;
}

foo(); //5 - переменная доступна
```

## Отличия let и const от var

Переменные, объявленные с помощью ключевых слов let и const в отличие от var:

1. Имеют блочную область видимости.

  Данный код выведен 10 раз подряд число 10. 
  
  ```js
  function foo() {
    for (var i = 0; i < 10; i++) {
      setTimeout(function() {
        console.log(i);
      }, 1000);
    }
  }
  foo(); //10 10 10... 10 раз
  ```


  В этом случае будет выведено 0, 1, 2, 3, ...  
  
  ```js
  function foo() {
    for (let i = 0; i < 10; i++) {
      setTimeout(function() {
        console.log(i);
      }, 1000);
    }
  }
  foo(); //10 10 10... 10 раз
  ```
  
  Этот пример еще раз подтверждает, что при использовании var (с функциональной ОВ) **все функции таймера "замкнут" одну переменную**, которая изменится 10 раз, и только потом таймеры будут вызваны.
  При использовании let (с блочной ОВ) в каждой итерации цикла будет своя переменная, и **каждая отдельная функция таймера "замкнет" эту отдельную переменную**. Если объявить let не в цикле, а в начале функции (перед циклом), то будет ситуация, аналогичная var, потому что переменная одна, общая для всех функций.

2. Не всплывают (а), однако имеют эффект "временной мертвой зоны" (б).

  а.
    ```js
    if (true) {
      console.log(b);
      let b = 10; //reference error: b is not defined
    }
    ```
  б.
    ```js
    let b = 20;
    if (true) {
      console.log(b);
      let b = 10; //reference error: b is not defined
    }
    ```
  В случае б, несмотря на то, что переменная b была объявлена вне блока и должна быть доступна, интерпретатор выдает ошибку, т.к. при запуске кода из блока происходит резервирование имен всех переменных, объявленных внутри блока. Чтобы избежать ошибки,необходимо всегда объявлять переменные в начале блока.


## Отличия const от let

Const – переменные, которые нельзя заново инициализировать. То есть нельзя менять литерал или ссылку. Однако можно добавлять/изменять элементы в массиве, или свойства в объекте.

```js
const lit = 4;
lit = 5; //typeerror

const obj = { a: 1 };
obj.a = 2; //можно изменить свойство
obj.b = 3; //можно добавить свойство
obj = { a: 3}; //typeerror - изменить ссылку

const arr = [1, 2, 3];
arr[1] = 0; //можно изменить значение элемента
arr.push(3); //можно добавить элемент
arr = [1, 2]; //typeerror - нельзя изменить ссылку
```

